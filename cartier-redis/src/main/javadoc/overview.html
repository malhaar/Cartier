<body>
<a href="http://github.com/lettuce-io/lettuce-core">lettuce</a> is a scalable thread-safe Java
{@link com.lambdaworks.redis.RedisClient RedisClient} providing
{@link com.lambdaworks.redis.api.sync.RedisCommands synchronous},
{@link com.lambdaworks.redis.api.async.RedisAsyncCommands asynchronous} and
{@link com.lambdaworks.redis.api.rx.RedisReactiveCommands reactive} APIs for Redis Standalone, PubSub,
Redis Sentinel and {@link com.lambdaworks.redis.cluster.RedisClusterClient Redis Cluster}.

Multiple threads may share one connection if they avoid blocking and transactional
  operations such as <a href="http://redis.io/commands/blpop">BLPOP</a> and
  <a href="http://redis.io/commands/multi">MULTI</a>/<a href="http://redis.io/commands/exec">EXEC</a>.
  Multiple open connections are efficiently managed by the excellent
<a href="http://www.netty.io">netty</a> NIO framework.

  <p>
    Each redis command is implemented by one or more methods with names identical to the lowercase
    redis command name. Complex commands with multiple modifiers that change the result type include
    the CamelCased modifier as part of the command name, e.g.
    {@link com.lambdaworks.redis.api.sync.RedisCommands#zrangebyscore zrangebyscore} and
    {@link com.lambdaworks.redis.api.sync.RedisCommands#zrangebyscoreWithScores zrangebyscoreWithScores}.
  </p>

  <p>
    Redis connections are designed to be long-lived, and if the connection is lost will reconnect
    until {@code close()} is called. Pending commands that have not timed out will be (re)sent after
    successful reconnection.
  </p>

  <p>
    All connections inherit a default timeout from their {@link com.lambdaworks.redis.RedisClient}
    and will throw a {@link com.lambdaworks.redis.RedisException} when non-blocking commands fail
    to return a result before the timeout expires. The timeout defaults to 60 seconds and
    may be changed via {@link com.lambdaworks.redis.RedisClient#setDefaultTimeout} or for
    each individual connection.
  </p>
</body>
